<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/04/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-05-04T19:12:55+08:00" content="2016-05-04">
              2016-05-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/22/2016-04-23-Fix Contributions/" itemprop="url">
                  煮熟的Contributions飞了？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-22T01:25:24+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>###问题背景</p>
<p>最近突然发现我在Github上的Blog提交都没被计算Contributions，以下是解决过程，特此记录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这篇主要讲一下我遇到的问题和如何解决：一直在github上写blog，最近发现我每次提交，竟然没有被算contributions，也就是没有出现绿方块，这让我有点郁闷啊，虽说写blog不是会了哪几个绿色方块，但是该有的还是得有啊，没有绿色方块也不方便看自己更新的情况啊。。。。。</span><br><span class="line"></span><br><span class="line">###怎么样才会被算Contributions?</span><br><span class="line"></span><br><span class="line">关于这个Github官方的解释在这里 </span><br><span class="line">[Why are my contributions not showing up on my profile?](https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/)</span><br><span class="line"></span><br><span class="line">不过呢，是英文的，23333，勉强能看懂，简单翻译一下</span><br><span class="line"></span><br><span class="line">####Issues and pull requests</span><br><span class="line"></span><br><span class="line">* 一年之内执行的</span><br><span class="line">* Fork的仓库不算，要独立的仓库</span><br><span class="line"></span><br><span class="line">####Commits</span><br><span class="line"></span><br><span class="line">* 一年之内Commit的操作</span><br><span class="line"></span><br><span class="line">* Commit的Email的地址与Github关联</span><br><span class="line"></span><br><span class="line">* 在一个独立仓库提交，Fork的不行</span><br><span class="line"></span><br><span class="line">* 提交的分支：</span><br><span class="line">    * 默认分支（一般是`master`）</span><br><span class="line">    * `gh-pages`分支（包含`Project Pages sites`的仓库） </span><br><span class="line"></span><br><span class="line">另外，至少满足以下条件中的一个（主要针对对不是你创建的仓库的Commit）：</span><br><span class="line"></span><br><span class="line">* 仓库的协作者，或者是仓库的组织中的一员</span><br><span class="line"></span><br><span class="line">* Fork的仓库</span><br><span class="line"></span><br><span class="line">* 对这个仓库发起过Pull Request或者Issue</span><br><span class="line"></span><br><span class="line">* Star这个仓库</span><br><span class="line"></span><br><span class="line">####Contributions没被计算的常见原因</span><br><span class="line">* 进行Commits的Email没有被关联到Github帐号。</span><br><span class="line"></span><br><span class="line">* 没在仓库的默认分支进行Commit。</span><br><span class="line"></span><br><span class="line">* 不是对独立仓库Commit而是一个Fork仓库</span><br><span class="line"></span><br><span class="line">* 提交合并和压合的Pull Request</span><br><span class="line"></span><br><span class="line">###找回我煮熟的Contributions</span><br><span class="line"></span><br><span class="line">####定位原因</span><br><span class="line">根据Github官方的解释，我很快找到我的Contributions飞走的原因，那就是Commit的Email地址不对，我的Email为`XXX@XX.Local`，这样的Email自然Github不认识了。</span><br><span class="line"></span><br><span class="line">####对症下药</span><br><span class="line">首先为了以后的Commits能被正确计算，我先改掉我提交的Eamil地址。</span><br><span class="line"></span><br><span class="line">* 可以用Github Desktop的GUI界面更改，在偏好设置里</span><br><span class="line">* 可以命令行直接改 </span><br><span class="line">          </span><br><span class="line">    $ git config --global user.email johndoe@example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么以前的Contributions怎么办？绝不能就这样让他们飞了啊，想要找回之前的Contributions，就要改掉之前提交记录的Email。</span><br><span class="line"></span><br><span class="line">Github官方也有解决方案[Changing author info](https://help.github.com/articles/changing-author-info/) ，嗯，同样是英文的。。。</span><br><span class="line"></span><br><span class="line">#####使用脚本更改仓库的Git历史</span><br><span class="line"></span><br><span class="line">* 打开Terminal</span><br><span class="line"></span><br><span class="line">* 对你的仓库创建一个新的Clone，并前往目录</span><br><span class="line"></span><br><span class="line">        git clone --bare https://github.com/user/repo.git</span><br><span class="line">        cd repo.git</span><br><span class="line">      </span><br><span class="line">* 复制粘贴以下脚本，根据你的信息修改以下变量</span><br><span class="line">`OLD_EMAIL`,`CORRECT_NAME`,`CORRECT_EMAIL`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #!/bin/sh</span><br><span class="line">      </span><br><span class="line">        git filter-branch --env-filter &apos;</span><br><span class="line">      </span><br><span class="line">        OLD_EMAIL=&quot;your-old-email@example.com&quot;</span><br><span class="line">      </span><br><span class="line">        CORRECT_NAME=&quot;Your Correct Name&quot;</span><br><span class="line">      </span><br><span class="line">        CORRECT_EMAIL=&quot;your-correct-email@example.com&quot;</span><br><span class="line">      </span><br><span class="line">        if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">      </span><br><span class="line">        then</span><br><span class="line">      </span><br><span class="line">            export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">          </span><br><span class="line">            export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">          </span><br><span class="line">        fi</span><br><span class="line">      </span><br><span class="line">            if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">          </span><br><span class="line">        then</span><br><span class="line">      </span><br><span class="line">            export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">            export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">          </span><br><span class="line">        fi</span><br><span class="line">      </span><br><span class="line">        &apos; --tag-name-filter cat -- --branches --tags</span><br><span class="line"></span><br><span class="line">* 按Enter键运行脚本</span><br><span class="line"></span><br><span class="line">* 查看更改后的Git历史有没有错误</span><br><span class="line"></span><br><span class="line">* 把正确的历史 Push 到 Github</span><br><span class="line"></span><br><span class="line">        git push --force --tags origin &apos;refs/heads/*&apos;</span><br><span class="line">        </span><br><span class="line">* 删掉刚才临时Clone的仓库</span><br><span class="line"></span><br><span class="line">	    cd ..</span><br><span class="line">	    rm -rf repo.git</span><br><span class="line">	  </span><br><span class="line">###结语</span><br><span class="line">按以上步骤执行完之后，我煮熟的Contributions终于回来了，圆满解决困扰~~</span><br></pre></td></tr></table></figure></p>
<p>###引用致谢<br><a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/" target="_blank" rel="external">Why are my contributions not showing up on my profile?</a></p>
<p><a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="external">Changing author info</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/2016-04-17-Swift Note 01/" itemprop="url">
                  入坑Swift
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-17T08:25:24+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>上周正式入坑Swift，于是总结一下Swift相关的编程</p>
<p>###面向协议</p>
<p>大家都说Swift是适合面向协议编程，而不是OC的面向对象。</p>
<p>那么为什么这么说</p>
<p>我自己想想大概是基于Swift以下几个特性：</p>
<ul>
<li>协议能被枚举、结构体、类实现</li>
<li>协议能够被扩展，提供默认实现</li>
<li>枚举，结构体基本都能实现一个类能实现的功能，并且都能被扩展</li>
</ul>
<p>那么说一下我目前用到的面向协议编程的实战</p>
<p>首先App有一个设置页面，设置页面大家应该很熟，一个<code>TableView</code>，<code>Cell</code>里两个<code>UILabel</code> + 一个<code>Switch</code></p>
<p>在面向对象编程中，一般会对<code>Cell</code>做一个<code>configure</code>配置方法如下</p>
<pre><code>func configure(title: String, 
          titleColor: UIColor,
         description: String, 
    descriptionColor: UIColor,
            switchOn: Bool, 
       switchHandler: switchTogglerHandlerType? = nil) {

    // 根据参数配置视图

 }
</code></pre><p>这个<code>configure</code>方法，还没考虑字体啥的，而且还用到了Swift默认值特性简化了一下<code>switchTogglerHandlerType</code>。但<code>configure</code>依然会写得很长很臃肿，在调用的时候写成一坨，不好看又麻烦啊。这个时候，聪明如你，你会说把参数封成一个Model，然后在Model里设置完这些东西呗，这样就只有一个参数了。那么Switch开关的操作呢？Switch开关所对应的操作要操作数据库不同的字段balabala</p>
<p>这个时候我们再来想一个问题，这种样式的Cell在App中很常见，你很可能要在其他界面复用这个Cell，只是颜色不完全一样，开关要操作的东西不一样，这个时候你初始化Model的时候同样要写一长串代码来设置属性。</p>
<p>为了考虑这个情况，面向对象的想法下，你可能会抽一个基Model，派生不同样式配置和开关操作的Model；或者给Model加一个Type的枚举字段，在Model内部根据枚举来做默认配置。但是Swift很不建议大量使用Class，建议多使用协议还有结构体这种值类型</p>
<p>我们来看一下面向协议编程的解决方案，我们来写面向协议的Model。</p>
<p>首先我们定义一个协议 <code>LabelWithSwitchCellProtocol</code></p>
<pre><code>protocol LabelWithSwitchCellProtocol {
    var title: String { get }
    var titleColor: UIColor { get }
    var description: String { get }
    var descriptionColor: UIColor { get }

    var switchOn: Bool { get }

    func switchToggle(on: Bool)
}
</code></pre><p>然后我们可以扩展协议做一些默认实现，如下</p>
<pre><code>extension LabelWithSwitchCellProtocol {
    var titleColor: UIColor {
        return .blackColor()
    }

    var descriptionColor: UIColor {
        return .lightGrayColor()
    }
}
</code></pre><p>然后在Cell里的configure方法我们这样写</p>
<pre><code>func configure(delegate: LabelWithSwitchCellProtocol)

{
    // 在这里配置方法
}
</code></pre><p>然后我们开始写Model，如下</p>
<pre><code>struct PhoneSettingCellViewModel: LabelWithSwitchCellProtocol {

    var title = &quot;Phone&quot;
    var description = &quot;Setting Phone Switch&quot;

    var switchOn = true

    func switchToggle(on: Bool) {
        if on {
            print(&quot;The phone is On&quot;)
        } else {
            print(&quot;The phone is Off&quot;)
        }
    }
}
</code></pre><p>调用如下</p>
<pre><code>cell.configure(PhoneSettingCellViewModel())
</code></pre><p>当然我们还可以写其他地方要复用到Cell的不同功能的ViewModel，同时亦可以LabelWithSwitchCellProtocol拆成两个协议：<code>DataSource</code>和<code>Delegate</code>来分离实现，提高代码可读性等等</p>
<p>#####这样的写法有什么好处？个人认为以下几点</p>
<ul>
<li>Cell不用关心具体用的是哪一种Model，只要Model遵循了Cell的协议就可以</li>
<li>扩展性比较好，设计师随时要加一种样式，我加一种ViewModel就可以无缝连接，不用改原来的代码</li>
<li>Cell复用起来比较方便</li>
<li>有些时候ViewModel会涉及到数据库的操作和其他的操作，这个时候你的VM编写没有那么快，那么先用Protocol定义View所需要的字段简单实现一个VM，用于界面显示神马的，等到完整的VM写好后，直接替换就好，因为你只定义了VM是遵循某个Protocol而不是直接指定VM是哪一个VM</li>
</ul>
<p>其实你可能会觉得这样也没有多好，而且用类继承或者枚举判断也可以实现，为什么非要用面向协议，就因为大家这么说了我就要用？反正一开始我是这么想的。。。</p>
<p>那么，我们再来考虑一下一个场景，上面那个例子是Cell有UILabel和Switch。可能另一个界面的一个View也是这样，有UILabl和Switch，唉我是不是要在定义View的协议，然后一套再来一遍？</p>
<p>这个时候我们可以考虑更细化下去，创建标签协议，比如标题Label协议（<code>TitleTextPresentable</code>），描述Label协议(<code>DescriptionTextPresentable</code>)，Switch协议(<code>SwitchPresentable</code>)。</p>
<p>然后我们的View或Cell的ViewModel按需扩展协议。</p>
<pre><code>extension SwitchWithTextViewModel: TitleTextPresentable {
    var title: String { return &quot;title&quot; }
    var titleColor: UIColor { return .blackColor() }
    var font: UIFont { return .systemFontOfSize(17.0) }
}

extension SwitchWithTextViewModel: SwitchPresentable   {

    var switchOn: Bool { return false }
    var switchColor: UIColor { return .yellowColor() }

    func onSwitchToggleOn(on: Bool) {
        if on {
            print(&quot;On!&quot;)
        } else {
            print(&quot;Off&quot;)
        }
    }
}
</code></pre><p>View中我们这么写</p>
<pre><code>class SwitchWithTextView&lt;T where T: TitleTextPresentable, T: SwitchPresentable&gt;: UIView {

    func configure(delegate: T) {
        // 在这里配置视图
    }
}
</code></pre><p>这里用到了泛型，因为View实在不用关心传进来的Model具体是什么，只需关心这个Model是否实现了该实现的东西。Cell也是如此，用三个拆开的协议代替了Cell本身的协议。这样这些协议的定义达到了高度的复用。</p>
<p>这样子是否会让你觉得有点好用呢？反正我觉得有点，23333</p>
<p>关于面向协议编程要讲的暂时就到此为止了，初学者还在继续摸索。。。。</p>
<p>###协议<br>这里主要讲一下protocol具体的一些语法注意事项</p>
<p>在属性声明后写上{ get set }表示属性为可读写的。{ get }用来表示属性为可读的。即使你为可读的属性实现了setter方法，它也不会出错</p>
<p>用类来实现协议时，使用<code>class</code>关键字来表示该属性为类成员；用结构体或枚举实现协议时，则使用<code>static</code>关键字来表示</p>
<p>函数前缀加上<code>mutating</code>关键字来表示该函数允许改变该实例和其属性的类型，用class实现协议中的<code>mutating</code>方法时，不用写<code>mutating</code>关键字；用结构体，枚举实现协议中的<code>mutating</code>方法时，必须写<code>mutating</code>关键字</p>
<p>即时满足了协议的所有要求，类型也不会自动转变，必须为它做出明显的协议声明</p>
<p>可选协议只能在含有<code>@objc</code>前缀的协议中生效,且<code>@objc</code>的协议只能被类遵循。可选协议含有可选成员，其遵循者可以选择是否实现这些成员。在协议中使用<code>@optional</code>关键字作为前缀来定义可选成员</p>
<p>多个协议别名成一个协议<br><code>typealias SettingCellPresentable = protocol&lt;                                                 TitleTextPresentable, DescriptionTextPresentable, SwitchPresentable&gt;</code></p>
<p>扩展协议来实现提供默认方法</p>
<p>###值类型VS引用类型</p>
<p>值类型(value types)，每个值类型的实例都拥有各自唯一的数据，通常它们是结构体，枚举或元组；</p>
<p>引用类型(reference types)，引用类型的实例共享它们的数据，通常是一个类。</p>
<p>我理解值类型复制时是深拷贝；而引用类型是浅拷贝，即指针拷贝</p>
<p>Swift建议使用值类型来保证安全性，以避免不必要的数据共享造成的bug</p>
<p>以下是两者选择的一些准则，就直接引用网上的说明了，没啥好个人总结的</p>
<p>使用值类型的情形：</p>
<ul>
<li>使用==运算符比较实例数据的时候。</li>
<li>你想单独复制一份实例数据的时候。</li>
<li>当在多线程环境下操作数据的时候。</li>
</ul>
<p>使用引用类型（比如class）的情形：</p>
<ul>
<li>当使用===运算符判断两个对象是否引用同一个对象实例的时候。</li>
<li>当上下文需要创建一个共享的、可变的对象时。</li>
</ul>
<p>###引用致谢<br><a href="http://letsswift.com/2014/06/protocols/" target="_blank" rel="external">协议 http://letsswift.com/2014/06/protocols/</a></p>
<p><a href="http://letsswift.com/2014/08/value-type-and-reference-type/" target="_blank" rel="external">值类型与引用类型 http://letsswift.com/2014/08/value-type-and-reference-type/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/06/2016-04-06-Computer Networking 02/" itemprop="url">
                  计算机网络知识归纳《二》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-06T09:25:24+08:00" content="2016-04-06">
              2016-04-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="计算机网络自顶向下分层"><a href="#计算机网络自顶向下分层" class="headerlink" title="计算机网络自顶向下分层"></a>计算机网络自顶向下分层</h3><ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<p>这五层，我主要学习是前三层：应用层、运输层、网络层，因为下面两层是比较偏硬件的内容。</p>
<p>对这三层目前我自己的一个笼统的认识：</p>
<ul>
<li>应用层产生的报文分组，传给运输层</li>
<li>运输层对报文加上运输层首部，封装成运输层的分组报文段运输层将报文段传给网络层</li>
<li>网络层对报文段加上网络层首部，封装成网络层分组数据报，再传递到下一层。</li>
</ul>
<h3 id="因特网构成描述"><a href="#因特网构成描述" class="headerlink" title="因特网构成描述"></a>因特网构成描述</h3><p>在互联网世界，端系统（PC、移动设备等）通过通信链路和分组交换机连接。</p>
<p>分组交换机的作用是转发分组，一般分为路由器和链路层交换机。<br>路由器会涉及到三层（物理层、链路层、网络层），链路层交换机会涉及到两层（物理层、链路层）。因此路由器会有一个转发表（将目的地址映射到输出链路，用以选择链路，即所谓的选路协议）。</p>
<p>ISP（因特网服务提供商）包含多个交换机和多段通信链路，运行IP协议</p>
<p>链路和交换机移动数据的方式：电路交换，分组交换。两者主要区别可以类比成去餐馆吃饭是否需要预定位子，前者需要，后者不需要。</p>
<p>####电路交换<br>每条链路规定N条电路（对应一个连接），宽带限制为1/N，在这种情况下，即使别人没在使用带宽，你依然只能使用到1/N的带宽，造成极大的一种浪费</p>
<p>电路交换分频多路复用</p>
<ul>
<li>时分多路复用 ： 以时间为单位，周期性获得所有带宽</li>
<li>频分多路复用 ： 对信道分频，连续获得部分带宽</li>
</ul>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>储存转发传输：交换机转发分组钱必须接收到整个分组 -&gt; 储存转发时延</p>
<p>交换机有一个输出缓存，存储需转发的分组，以此这里会有一个排队现象 -&gt;排队时延</p>
<p>当输出缓存完全充满，那么会造成丢包现象</p>
<p>分组交换主要有以下几种时延现象</p>
<ul>
<li>节点处理时延 ： 检查分组首部，决定将分组导向何处</li>
<li>排队时延</li>
<li>传输时延 ： 由传输带宽和传输数据的大小决定，分组长度/链路速率</li>
<li>传播时延 ： 一个物理距离的概念，路由器之间的距离/物理媒介传播速度</li>
</ul>
<p>传播VS传输 ：为了具象的描述两者的不同，用收费站和车辆来做类比<br>车队（很多车辆） -&gt; 分组<br>传输 ： 收费站处理一辆车收费的时间<br>传播 ： 车从A收费站开到B收费站的时间</p>
<h4 id="流量强度"><a href="#流量强度" class="headerlink" title="流量强度"></a>流量强度</h4><p>公式 = La/R (L分组的比特长度、R传输速度、a每秒到达队列的分组的个数)</p>
<p>流量强度 大于1时，排队时延会趋向于无穷大</p>
<p>同事流量强度越大代表着丢包现象越严重，因为缓存区内存固定 </p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>一个链路上对数据传输的速度，取决于数据流过的链路的最小传输速度</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>网络应用程序及应用层协议存留的地方</p>
<p>主要协议</p>
<ul>
<li>HTTP协议 （Web文档请求传送）</li>
<li>SMTP协议 （电子邮件报文传输）</li>
<li>FTP协议  （端系统文件传递）</li>
<li>DNS协议  （域名映射系统）</li>
</ul>
<p>分组 ： 报文</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>一个无状态协议，不会记录用户的操作，所以几秒钟内发两次一样的请求，服务器将重新发送对象，服务器不存储客户机的信息。</p>
<p>为此，为避免大量一样的数据被反复发送和识别用户，会结合使用cookie技术和Web缓存器（一般ISP使用）</p>
<h5 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h5><p>技术组成</p>
<ul>
<li>在HTTP响应中有一个cookie首部行</li>
<li>在HTTP请求中有一个cookie首部行</li>
<li>在用户端系统中保留一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库</li>
</ul>
<p>当第一次访问某网站，Web站点产生唯一一个识别码，并以此作为索引在后端数据库产生表项。同时服务器的响应报文会包含一个<code>set-cookie：</code>的首部行。</p>
<p>当浏览器接受到响应报文时，会在它管理的特定cookie文件添加一行，其中包含该服务器的主机名和<code>set-cookie：</code>中的识别码。</p>
<p>之后继续访问该站点时，浏览器会在HTTP请求报文中增加含有cookie的首部行<code>cookie：</code></p>
<h5 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h5><p>Web缓存器有自己的磁盘存储空间，并在该存储空间保存最近请求过的对象的拷贝。通过配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器，然后会发生以下情况</p>
<p>浏览器和Web缓存器建立TCP连接，并向Web缓存器发送HTTP请求</p>
<p>Web缓存器检查本地是否存储了该对象拷贝，如果有就用HTTP响应报文返回对象；如果没有，它就与对象的初始服务器建立TCP连接，并发送获取的HTTP请求，然后接受初始服务器发送的HTTP响应。</p>
<p>Web缓存器接收到对象时，在本地存储空间存储一份拷贝，并用HTTP响应报文发回给浏览器</p>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>FTP是一个有状态协议，使用两个并行的TCP连接：控制连接和数据连接。控制连接负责验证账号，数据连接负责数据的传递。控制连接贯穿整个过程，数据连接每次文件传输都会建立（非持久）。</p>
<p>FTP的控制信息被称为带外传送。</p>
<h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>电子邮件主要涉及结构：用户代理，邮件服务器，SMTP协议</p>
<p>邮件传输过程简述</p>
<p>邮件从用户代理传输到邮件服务器，再传到接收方的邮件服务器，再传到接受<br>方的用户代理。SMTP用于邮件服务器之间传送文件和发送方将数据发送至邮件服务器（一般情况下，现在也有使用HTTP协议的），接收方从邮件服务器拉取邮件时主要使用POP3、IMAP、HTTP等协议。</p>
<p>所以相比HTTP协议，SMTP是一个推协议。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS即域名系统，用于识别主机，基于UDP协议</p>
<p>DNS构成</p>
<ul>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个允许主机查询分布式数据库的应用层协议</li>
</ul>
<p>DNS服务器层次结构（自顶向下）</p>
<ul>
<li>根DNS服务器</li>
<li>顶级域（TLD）服务器</li>
<li>权威服务器</li>
<li>本地服务器（存于ISP，代理作用，将主机的请求转发到DNS服务器层次结构）</li>
</ul>
<p>查询流程</p>
<ol>
<li>主机的查询请求先发往本地DNS服务器</li>
<li>本地服务器将请求转发至根DNS服务器，根DNS服务器返回对应的TLD服务器。</li>
<li>本地服务器将请求发至该TLD服务器，TLD服务器返回对应的权威服务器地址。</li>
<li>本地服务器将请求发至该权威服务器，权威服务器返回请求中主机名的IP地址。</li>
</ol>
<p>DNS查询是递归查询和迭代查询的结合：从请求主机到本地DNS服务器的查询是递归，其他的查询是迭代查询（根服务器返回TLD服务器的IP列表，TLD服务器返回返回权威服务器地址，请求通过这种迭代向服务器查询）</p>
<p>DNS缓存</p>
<p>为减少DNS报文数量，使用缓存。在请求链中，当一个DNS服务器接受一个DNS回答是，DNS服务器能将回答的信息缓存在本地存储器。当DNS服务器缓存了一个主机名/IP地址对，另一个对相同书记名的查询到达该DNS服务器时，该服务器能够提供所要求的IP地址，即使它不是该主机名的权威服务器。</p>
<h4 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h4><ul>
<li>HTTP ： 80</li>
<li>SMTP ： 25</li>
<li>FTP  ： 21（控制）、20（数据）</li>
<li>DNS  ： 53</li>
</ul>
<h3 id="引用致谢"><a href="#引用致谢" class="headerlink" title="引用致谢"></a>引用致谢</h3><p>《计算机网络 自顶向下方法》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/28/2016-03-28-Runtime/" itemprop="url">
                  关于Runtime的一些知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-28T09:25:24+08:00" content="2016-03-28">
              2016-03-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>###发送消息</p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>每个对象实例都有一个isa指针，指向自己的类对象（单例）。类对象的元数据保存了方法列表，实例变量列表，cache（指向最近使用过的方法的地址），superclass指针（指向父类的类对象），同时也有一个isa指针，指向元类对象。元类对象的元数据保存了类方法列表，同时也有一个superclass指针，直接指向最顶层类的元类对象。最顶层类的元类对象的isa指针指向自己，superclass指针指向类对象，类对象的superclass指针为nil。</p>
<pre><code>typedef struct objc_class *Class;

struct objc_class {
    Class isa; // 指向metaclass  

    Class superclass;  // 指向父类Class
    const char *name;  // 类名 
    uint32_t version;  // 类的版本信息
    uint32_t info;     // 一些标识信息，标明是普通的Class还是metaclass
    uint32_t instance_size;         // 该类的实例变量大小(包括从父类继承下来的实例变量);
    struct old_ivar_list *ivars;    //类中成员变量的信息
    struct old_method_list **methodLists;    类中方法列表
    Cache cache;    查找方法的缓存，用于提升效率
    struct old_protocol_list *protocols;  // 存储该类遵守的协议  
}

struct old_method_list {
    void *obsolete;      //废弃的属性
    int method_count;    //方法的个数
    /* variable length structure */
    struct old_method method_list[1];    //方法的首地址
};

struct old_method {
    SEL method_name;     //函数的SEL
    char *method_types;  //函数的类型
    IMP method_imp;      //函数指针
};
</code></pre><p><img src="https://github.com/DEMO0130/DEMO0130.github.io/blob/master/assets/images/runtime02.png?raw=true" alt="Mou icon"></p>
<h4 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h4><p>一种不透明的类型，它代表着一个方法选择器。<code>SEL</code>本质是一个int类型的地址，指向存储的方法名</p>
<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend()"></a>objc_msgSend()</h4><p>对象调方法其实是发消息，具体调用哪一个方法在运行时决定。<br>现在<code>cache</code>里找，没找到通过<code>selector</code>先从自身类对象的<code>methodList</code>查找是否有该<code>selector</code>的<code>method</code>（存放着<code>selector</code>,<code>IMP</code>，<code>IMP</code>是函数指针，指向具体要执行的函数的地址），没找到就向上一级父类找。如果最终找到，为降低查找次数会将这个<code>method</code>加入<code>cache</code>，下次调用就不用再来找一遍了。</p>
<p>如果没找到进入消息转发流程。</p>
<ul>
<li>obj-&gt;isa <code>obj</code>对象通过<code>isa</code>属性拿到对应的<code>Class</code></li>
<li>cache-&gt;method_imp 在<code>cache</code>找<code>selector</code>对应的<code>IMP</code>，如果找到通过<code>IMP</code>调用函数，没找到则继续以下步骤</li>
<li>class-&gt;methodLists <code>Class</code>通过<code>methodLists</code>属性拿到存放所有方法的列表</li>
<li>method_list-&gt;method <code>method_list</code>中通过SEL查找到对应的<code>method</code></li>
<li>method-&gt;method_imp <code>method</code>通过<code>method_imp</code>属性拿到函数指针</li>
<li>method_imp-&gt;调用函数 通过函数指针调用函数，加入<code>cache</code></li>
<li>最终若是没找到方法，则进入消息转发的流程。</li>
</ul>
<h4 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h4><p>在运行时偷换selector对应的IMP</p>
<ul>
<li><code>method_exchangeImplementations</code> 来交换2个方法中的IMP，</li>
<li><code>class_replaceMethod</code> 来修改类，</li>
<li><code>method_setImplementation</code> 来直接设置某个方法的IMP</li>
</ul>
<p>###消息转发<br>先看一张图<br><img src="https://github.com/DEMO0130/DEMO0130.github.io/blob/master/assets/images/runtime01.jpg?raw=true" alt="Mou icon"></p>
<h4 id="Method-Resolution"><a href="#Method-Resolution" class="headerlink" title="Method Resolution"></a>Method Resolution</h4><p>首先，<code>Objective-C</code> 运行时会调用 <code>+resolveInstanceMethod:</code><br>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES， 那运行时系统就会重新启动一次消息发送的过程；如果 resolve 方法返回 NO ，运行时就会移到下一步：Message Forwarding</p>
<h4 id="Fast-forwarding"><a href="#Fast-forwarding" class="headerlink" title="Fast forwarding"></a>Fast forwarding</h4><p>如果目标对象实现了 <code>-forwardingTargetForSelector:</code> ，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是 nil 和 self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续 Normal Fowarding 。</p>
<h4 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h4><p>它会发送 <code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。</p>
<p>如果 <code>-methodSignatureForSelector:</code>返回 nil ，Runtime 则会发出 <code>-doesNotRecognizeSelector:</code>消息，程序crash。</p>
<p>如果返回了一个函数签名，Runtime 就会创建一个 <code>NSInvocation</code> 对象并发送 <code>-forwardInvocation:</code>消息给目标对象。</p>
<p><code>NSInvocation</code> 实际上就是对一个消息的描述，包括<code>selector</code> 以及参数等信息。所以你可以在 <code>-forwardInvocation:</code><br>里修改传进来的 <code>NSInvocation</code> 对象，然后发送 <code>-invokeWithTarget:</code><br>消息给它，传进去一个新的目标。</p>
<h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><ul>
<li><p>Runtime 会发送 <code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>尝试去 resolve 这个消息；</p>
</li>
<li><p>如果 resolve 方法返回 NO，Runtime 就发送 <code>-forwardingTargetForSelector:</code>允许你把这个消息转发给另一个对象；</p>
</li>
<li><p>如果没有新的目标对象返回， Runtime 就会发送 <code>-methodSignatureForSelector:</code>和 <code>-forwardInvocation:</code>消息。你可以发送 <code>-invokeWithTarget:</code>消息来手动转发消息或者发送 <code>-doesNotRecognizeSelector:</code>抛出异常</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/23/2016-03-23-Computer Networking 01/" itemprop="url">
                  计算机网络知识归纳《一》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-23T13:25:24+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在投简历求面试，也补补一些相关知识，大学有一门课叫计算机网络，教材是本不错的书，可惜当时没好好学，所以只能现在努力啃，于是归纳一点知识。</p>
<p>本篇内容主要与HTTPS和TCP相关。</p>
<h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><ul>
<li>数字证书 由权威机构颁布，包含公钥，证书信息等</li>
<li>数字签名 对发送的数据hash算法加密形成摘要，对摘要用私钥加密，随数据一起发送给对方</li>
<li>https = http + TLS/SSL <ul>
<li>客户端发送支持的SSL协议、加密算法、产生的随机数</li>
<li>服务端选择SSL协议、加密算法、并将证书和随机数发给客户端</li>
<li>客户端验证证书有效性，随机生成一个“对称密码”，用服务端证书中的公钥加密生成“预主密码”，将“预主密码”发给客户端</li>
<li>（可选）如果服务器要求客户的身份认证，用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器</li>
<li>（可选）如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性；如果验证通过，经行下一步</li>
<li>服务器用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）</li>
<li>客户端向服务器发出信息，指明后面的数据通讯将使用主通讯密码为对称密钥，同时通知服务器客户端的握手过程结束。</li>
<li>服务器向客户端发出信息，指明后面的数据通讯将使用主通讯密码为对称密钥，同时通知客户端服务器端的握手过程结束</li>
<li>握手结束，接下来的将用主通讯密码对通信数据加密。</li>
</ul>
</li>
<li><p>tcp连接三次握手</p>
<ul>
<li>客户端发送SYN，SEQ=x报文给服务器端，进入SYN_SEND状态。</li>
<li>服务器端收到SYN报文，回应一个SYN ，SEQ=y，ACK(ACK=x+1）报文，进入SYN_RECV状态。</li>
<li>客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。</li>
</ul>
</li>
<li><p>tcp断开连接四次握手</p>
<ul>
<li>某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</li>
<li>FIN接收端执行 “被动关闭”（passive close），这个FIN由TCP确认，发回一个ACK，确认序号为收到的序号+1。注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</li>
<li>一段时间后，FIN接收端的应用进程将调用close关闭它的套接字。发回FIN给主动关闭方。</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN，发回ACK报文确认，并将确认序号设置为收到序号+1.</li>
</ul>
</li>
</ul>
<h3 id="引用致谢"><a href="#引用致谢" class="headerlink" title="引用致谢"></a>引用致谢</h3><p>《计算机网络 自顶向下方法》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/19/2016-03-19-Reading Note 01/" itemprop="url">
                  《Objective-C 高级编程》第一章读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-19T05:15:24+08:00" content="2016-03-19">
              2016-03-19
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>每次看这本书都会有新的收获，算起来这应该是第三次看这一章的内容了，决定把内容总结一下。</p>
<h3 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h3><p>自动引用计数：内存管理中对引用采取自动计数的技术，由编译器完成该工作。</p>
<p>在 MRC 时期（本人没有经历过）iOS程序员要手动管理内存，经常和retain，release，dealloc打交道，如果经验不丰富很容易造成内存泄露。于是有了 ARC 来解放程序员，但是还是应该了解一下其中道理，会有助于平时编程。</p>
<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul>
<li><p>当使用 alloc/new/copy/mutableCopy 或 前缀有这些关键字的方法时自己生成并持有对象，当调用系统提供的如NSMutableArray的类方法array，属于持有非自己生成的对象。类方法内部返回对象时会将对象注册到autoreleasepool。</p>
</li>
<li><p>autorelease 不立即释放，而是注册到autoreleasepool，当pool结束时对对象调用release</p>
</li>
<li><p>[obj autorelease]; 这句话取得但不持有对象，可用obj传递对象</p>
</li>
<li><p>NSZone 是一个历史遗留，基本上都不用，它通过多重区域来防止内存碎片化，但目前系统的内存管理以极具效率，再用这个反而造成干扰，一般批量使用内存并批量释放的情况才会考虑自己调用NSZone</p>
</li>
<li><p>引用计数采用散列表管理方式，key为内存地址，value为retain count，使用这种方式比较高效，可以通过内存地址追溯到内存块。</p>
</li>
<li><p>ARC 下，一般在需要及时释放大内存时使用autoreleasepool，例如大量的图像处理</p>
</li>
<li><p>autoreleasepool内部用数组来维护注册到autoreleasepool的对象，当pool结束时，遍历数组对每个对象发送release</p>
</li>
<li><p>对象作为返回值会被编译器自动注册到autoreleasepool</p>
</li>
</ul>
<ul>
<li><h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><p> ARC下默认用该关键字修饰变量，当变量超出作用域，强引用便失效，通过release释放变量</p>
<p>以下是一个初始化方法例子</p>
<pre><code>{
    id __strong obj = [[NSObject alloc] init];
}

以上代码的编译器的模拟代码如下

id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_releease(obj);
</code></pre><p>当我们使用类方法初始化会如何呢？</p>
<pre><code>{
    id __strong obj = [NSMutableArray array];
}

以上代码的编译器的模拟代码如下

id obj = objc_msgSend(NSMutableArray, @selector(array));
objc_retainAutoreleaseReturnValue(obj);
objc_releease(obj);
</code></pre><p>我们可以看到最后都是调用了objc_releease()方法，但是调类方法的时候多了一句objc_retainAutoreleaseReturnValue()，这有什么用呢？我们先来看看类方法内部实现。</p>
<pre><code>+ (instancetype)array {
    return [[NSMutableArray array] init];
}

以上代码的编译器的模拟代码如下

id obj = objc_msgSend(NSObNSMutableArrayject, @selector(alloc));
objc_msgSend(obj, @selector(init));
return objc_autoreleaseReturnValue(obj);
</code></pre><p>objc_autoreleaseReturnValue()，这个方法是返回注册到autoreleasepool的对象，除此之外它会检查执行命令列表，如果后面紧接着调用了objc_retainAutoreleaseReturnValue()，那么返回的对象就不注册到autoreleasepool，而是直接返回。objc_retainAutoreleaseReturnValue()这个方法即便是没有注册到autoreleasepool的对象也能正确地获取，这两个方法以此来实现直接传递，不用去autoreleasepool绕一圈，算是一种优化。</p>
</li>
<li><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><ul>
<li>weak使用一个散列表来维护(类似引用计数表)。对象被废弃时，在weak表中获取废弃对象为键值的记录，将记录中的对象置为nil；从weak表中删除该记录，从引用计数表中删除废弃对象的记录。</li>
<li><p>不改变对象的retainCount，但使用时会将对象retain(使用objc_loadWeakRetain方法)并注册到autoreleasepool，用完后马上释放(使用几次就注册几次，所以不要频繁使用weak对象，会增加开销)。这是为了确保weak变量在使用时是存在的。看下面这段代码。</p>
<pre><code>id obj = [[NSObject alloc] init];
id __weak obj1= nil;

obj1 = obj;

NSLog(@&quot;obj retainCount = %ld，obj1 retainCount = %ld&quot;,CFGetRetainCount((__bridge CFTypeRef)obj),CFGetRetainCount((__bridge CFTypeRef)obj1));
 NSLog(@&quot;obj1 retainCount = %ld，obj retainCount = %ld&quot;,CFGetRetainCount((__bridge CFTypeRef)obj1),CFGetRetainCount((__bridge CFTypeRef)obj));
 NSLog(@&quot;obj retainCount = %ld&quot;,CFGetRetainCount((__bridge CFTypeRef)obj));
 NSLog(@&quot;obj1 retainCount = %ld&quot;,CFGetRetainCount((__bridge CFTypeRef)obj1));CFTypeRef)obj1));

你将看到如下输出

2016-03-19 13:40:04.050 DEMO[71249:2320432] obj retainCount = 2，obj1 retainCount = 3
2016-03-19 13:40:04.050 DEMO[71249:2320432] obj1 retainCount = 3，obj retainCount = 3
2016-03-19 13:40:04.050 DEMO[71249:2320432] obj retainCount = 2
2016-03-19 13:40:04.050 DEMO[71249:2320432] obj1 retainCount = 3

可以看到weak 对象使用时还是会改变retainCount
</code></pre></li>
</ul>
</li>
<li><h4 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h4><p>等同于 ARC无效时调用对象的autorelease方法。</p>
</li>
<li><h4 id="Toll-Free-Bridge"><a href="#Toll-Free-Bridge" class="headerlink" title="Toll-Free Bridge"></a>Toll-Free Bridge</h4><p>在OC对象和CF对象互相转换时更改对象的被持有状况</p>
<p>__brideg_retain 和 CFBridgingRetain 等同于retain操作</p>
<p>__bridge_transfer 和 CFBridgeRelease 等同于release操作</p>
<p>__bridge 不更改所有权情况，单纯的转换。</p>
</li>
</ul>
<p>###引用致谢<br>《Objective-C 高级编程》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/2016-03-11-Code Coverage/" itemprop="url">
                  Code Coverage 杂谈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-12T01:31:24+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS-Code-Coverage-调研有感"><a href="#iOS-Code-Coverage-调研有感" class="headerlink" title="iOS Code Coverage 调研有感"></a>iOS Code Coverage 调研有感</h2><hr>
<h3 id="Code-Coverage-简介"><a href="#Code-Coverage-简介" class="headerlink" title="Code Coverage 简介"></a>Code Coverage 简介</h3><p>Code Coverage 顾名思义 代码覆盖率，一般指一个测试流程后，该测试所走过的代码率，以此可以检验测试的是否全面，版本是否可以发布。为什么我回去接触这个呢？首先，Xcode 7 有这个新功能，之前关注过，后来技术主管又叫我调研一下这个东东，目标是：以后测试人员测试的时候，生成覆盖率数据，来查看测试是否到位，是否足以测出代码硬伤bug。</p>
<p>于是就有了现在这篇Blog。</p>
<h3 id="Xcode7里的Code-Coverage"><a href="#Xcode7里的Code-Coverage" class="headerlink" title="Xcode7里的Code Coverage"></a>Xcode7里的Code Coverage</h3><p>从 Xcode 7 以来便自带了Code Coverage功能，苹果官方的WWDC Session里演示了Unit Test发起Code Coverage的操作。这个操作可以说是很方便很简单（当然是你本身就有写单元测试习惯的前提下，我没这习惯也不太会啊、摔），将项目的Test Scheme中的Gather coverage data选项勾起来，然后跑单元测试即可。</p>
<p>由于本人不太会写单元测试，于是下了别人写的例子，实际跑了跑，结果发现这个并不准啊，一些用到的函数硬生生的没覆盖到，显示次数为0。这坑啊，可能是功能刚出来，Xcode 7 还存在bug？我猜想是这样。</p>
<p>由于 Xcode 7 还有一个新功能叫UITest，有Test这个后缀，嗯、感觉也能跑Code Coverage，所以立马实验起来。实验结果同样不尽如人意啊，Bug更大的感觉，一些用Xib绑定起来的方法完全没覆盖上额。</p>
<p>综上，用 Xocde 7 自带的功能看来是败了。其实就算 Xcode 7 的自带功能没有bug，估计也不会被采用，毕竟最终目标是测试人员真机测试的时候记录覆盖率，测完之后从真机里拿到生成的覆盖率文件，所以不太可能让测试人员连着 Xcode 7 做测试，不太实际。于是转战其他方法。</p>
<h3 id="GCOV"><a href="#GCOV" class="headerlink" title="GCOV"></a>GCOV</h3><p>有一本书叫做《移动App测试实战》，书中第五章辅助测试方法中第二节代码覆盖率分析中讲解了iOS代码覆盖率技术方案。<br>主要使用了gcno和gcda文件来生成覆盖率数据文件，gcno包含了重建基本块图和相应的块的源码的行号的信息，gcda包含了弧跳变的次数和其他的概要信息，通过GCOV工具将两者结合，能直观的看到那些代码被覆盖到。</p>
<p>关于GCOV工具，我是用Homebrew安装的，后来找到不用写命令行的CoverStory工具。</p>
<p>步骤书中很详细，以下简单做了介绍。</p>
<ul>
<li>在项目info.plist里增加Application supports iTunes file sharing，设为YES。这一步是为了能通过iTunes共享文件拿到真机中的gcda文件。</li>
<li><p>如果App不涉及跨App跳转，那么在info.plist设置Application does not run in background为YES，这样App不会后台运行，每次按Home键便会写入gcda文件；如果涉及那边不用设置，而是为App增加一个写gcda文件的功能按钮，写入以下代码，在要更新覆盖率文件时便点击按钮。</p>
<pre><code>extern void __gcov_flush(void);
__gcov_flush();
</code></pre></li>
<li><p>在项目的Build Setting中将以下两项设置为YES。</p>
<pre><code>Instrument Program Flow
Generation Legacy Test Coverage Files
</code></pre></li>
<li><p>如果是真机测试，需要在main.m 的 main函数中 </p>
<pre><code>return UIApplicationMain
</code></pre><p>这行代码前加以下代码，作用是讲gcda文件生成在iTunes共享文件中，以便获取。</p>
<pre><code>const char * prefix = &quot;GCOV_PREFIX&quot;;
const char * prefixValue = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents/coverageData&quot;] cStringUsingEncoding:NSASCIIStringEncoding];
const char * prefixStrip = &quot;GCOV_PREFIX_STRIP&quot;;
const char * prefixStripValue = &quot;1&quot;;
setenv(prefix, prefixValue, 1);
setenv(prefixStrip, prefixStripValue, 1);
</code></pre></li>
<li><p>以上设置完毕就可以开始实际测试，build项目，在Mac上获取gcno文件，如果模拟器测试，会在同一位置获得gcda文件，如果是真机，那么真机连上电脑，会在iTunes中拿到gcda文件。</p>
</li>
<li>拿到gcno和gcda文件，放在同一个文件夹中，就剩下将两者合并的工作，可以用lcov命令行操作也可以装CoverStory这个工具直接查看。</li>
</ul>
<p>至此所有流程完毕，但在Xcode 7上还是有Bug，最终文件的line data列的覆盖次数显示得不对，是非常奇怪的数字，Xcode 6就不会如此，猜测Xcode 7 为了支持自带的Covreage功能做了什么修改。</p>
<p>另用Xcode 7.2.1打包的ipa，真机会出现gcda生成不完全，与gcno不匹配的现象。Xcode 7.3 Beta也不行，但是Xcode7.2 是可以的，这就不知道为何了。。。。<code>2016年4月22日晚补充：真机会出现gcda生成不完全，该问题在Xcode7.3正式版已不会出现；与gcno不匹配的现象，我的实验还会出现</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说这次调研不怎么成功吧，一直受到 Xcode 自身的干扰。。。</p>
<h3 id="引用致谢"><a href="#引用致谢" class="headerlink" title="引用致谢"></a>引用致谢</h3><p>《移动App测试实战》第五章第二节</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2015/410/" target="_blank" rel="external">WWDC 2015 Session 410 Continuous Integration and Code Coverage in Xcode </a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/05/2016-03-05-First Blog/" itemprop="url">
                  第一篇，初建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-05T08:31:24+08:00" content="2016-03-05">
              2016-03-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="这是第一篇Blog哦"><a href="#这是第一篇Blog哦" class="headerlink" title="这是第一篇Blog哦"></a>这是第一篇Blog哦</h4><hr>
<p>一直没想着搭Blog，觉得有点太Public，I am a private person。</p>
<p>但是觉得作为一个程序猿，真的应该认真做点神马了，搭个Blog也算是激励自己平时多看多做多积累吧。</p>
<p>这个Blog用了onevcat大大开源的主题，很好用啊，之前鼓捣另一个主题一上午没成功，换成这个主题马上搞定了，人品也是差，总之远程感谢onevcat大大~~~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
